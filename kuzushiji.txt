崩し字入力について

熟語を入力するとき、「崩し字入力」という方法を使うと2文字目の漢字の打鍵を省略できます。


右手の崩し字

例えば、今流行りのAI「人工知能」という熟語は、普通に打つと「人: dfk」、「工: csn」、「知: vdm」、「能: efl」ですが、
崩し字入力ではこれが、「人工: df【kn】」、「知能: vd【ml】」になります（【】はスペースキーを押しながらの同時押し）。

手書きの場合、文字を崩して書くことができますが、これも熟語の2文字目の最後の打鍵につながるよう、途中を崩すイメージで打つことができます。

上の例では、それぞれ6打必要な熟語を5打で打つことができます（スペースキーを含む）。同時打鍵なので実際は4打が2打になるような感覚です。

崩し字入力には打鍵効率以外のメリットもあります。それは最初の1文字さえ打てれば何とかなるという点です。

上の例では、右手の最初の1文字である「人」の最後のキーは「k」で、それと同時に押せる右手のキーを何か押せばそのうち「工」が出てきます。
打てる熟語の2文字目に覚えていない漢字が含まれているなら、熟語で出して不用な漢字を消す、という方法でその漢字を入力できます。


右手単打の崩し字

次に「人間」と打ちたい場合を考えます。これは「人: dfk」と「間: wrk」なのですが、どちらも右手打鍵が同じ「k」になっています。
このような熟語は「df【k】（スペースキーを押しながら「k」の単打）」で「崩せ」ます。


左手の崩し字

これで「人」で始まる熟語、「人為」や「人通*1」、「人気」、「人情」、「人出」、「人生」、「人我」、「人工」、「人件」、「人混み」、「人死*2」、そして「人間」を
打てるようになりました*。しかし、「人」で始まる熟語はこれだけではありません。

「人: dfk」の最終打鍵「k」を押しながら、左手の「w」、「e」、「r」、「s」、「d」、「f」、「x」、「c」、「v」を押すと、それぞれ、
「人形」、「人権」、「人体」、「人口」、「人々」、「人脈」、「人員」、「人材」、「人物」が出力されます

雪華の最初の左打鍵は、それぞれが漢字の分類に対応しています。それで2文字目には、「w: 建物」、「e: 動物」、「r: 植物」、「s: 体・手・足」、「d: 人・形状」、「f: 自然」、「x: 器」、「c: 道具」、「v: 武器」を意味する部品を含む漢字がくることになります。「口」という漢字の出し方を覚えていなくても、「体」に分類されていることさえ分かれば「人口」と打てるのです。

漢字熟語の数は多いので、これでもまだ足りません。今度は「dk」の後、スペースキーを押しながら「k」と先ほどの左手のキーを押してみてください。
「人柄」、「人質」、「人世」、「人事」、「人数」、「人里」、「人的」、「人種」、「人前」と出力されるはずです。
これらはより出現頻度の低い熟語です。キー配列に登録できる熟語の数には限りがあるので、出現頻度の高い熟語が押しやすい崩し方に優先的に登録されています（固有名詞は一部を除き、登録されていません*3）。


*1 「人通」の送り仮名は「人通（り）」となっている辞書もありますので、必須ではないようです。
*2 「人死」の送り仮名は「人死（に）」となっている辞書もありますので、必須ではないようです。
*3 常用漢字表の前書きには「この表は、都道府県名に用いる漢字及びそれに準じる漢字を除き、固有名詞を対象とするものではない」とあり、雪華もこれに倣い、都道府県や地域区分、国や地域（日本、中国、韓国、米国、台湾、香港、英国、欧州、朝鮮）、年号を除き、固有名詞は除外しています。



崩し字の実装について

キーの配置を変換するソフトウェアの中には、レイヤーの遷移数に制限が設けられているものがあります。KMonadの場合は「2」です。
カナ配列「薙刀式」から漢直「雪華」への同時2打鍵で遷移数を使い切ってしまうため、左手の崩し字の右手の押しっぱなしにレイヤー遷移を割り当てることができません。

しかしKMonadでは、遷移を使い切った後にHoldしようとすると元のカナ配列のレイヤーに戻るので、この挙動を利用して崩し字を実装しています。

例として、「固有」という漢字の崩し字を考えます。

「固: xcui」単体の場合のXComposeの最終出力は、
<Multi_key> <bracketleft> <x> <c> <bracketright> <u> <x> <c> <minus> <i> : "固"

これは読みやすくすると、以下のキーの羅列になります。
ralt [ x c ] u x c - i

この出力を得るためのKMonadの設定は以下のようになっていて、
xc-u (tap-next-release (around ralt (around [ #(x c - u XX))) (around ralt (around [ #(x c ] u XX))))
xc-i (tap-next-release (around ralt (around [ #(x c - i XX))) (around ralt (around [ #(x c ] i XX))))

このふたつは「xc」同時押し後のレイヤーの「u」と「i」に割り当てられている設定で、それぞれ以下のキーを出力します。
Tap: ralt [ x c - u / Hold: ralt [ x c ] u
Tap: ralt [ x c - i / Hold: ralt [ x c ] i

「u」をHoldしながら、「i」をTapして「固」を打つので、想定される出力はこのようになります。
ralt [ x c ] u ralt [ x c - i

実際には、後続の「ralt」と「[」はaroundで定義されているため重複せず、以下のようになります。
ralt [ x c ] u x c - i

「x」と「c」もaroundで定義すればよさそうですが、そうすると左手を使った崩し字の時に文字が吸収されてしまうので、このような冗長な表現になっています。

次に「固有: xcuie」のXComposeの最終出力を見てみます。
<Multi_key> <bracketleft> <x> <c> <bracketright> <u> <bracketright> <i> <minus> <e> : "固有

これも読みやすくすると、以下のようになります。
ralt [ x c ] u ] i - e

「u」のHoldの後、
ralt [ x c ] u

元のカナ配列「薙刀式」のレイヤーに戻され、以下の設定が呼び出されます。
ie  (around ralt #(] i - e XX)

この出力はこのようになります。
ralt ] i - e

これを「u」の出力と組み合わせ、後続のraltを削除すると「固有」の出力になります。
ralt [ x c ] u ] i - e
